<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://daheesong.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://daheesong.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-24T06:24:13+00:00</updated><id>https://daheesong.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Rapidly-Exploring Random Trees</title><link href="https://daheesong.github.io/blog/2025/RRT/" rel="alternate" type="text/html" title="Rapidly-Exploring Random Trees"/><published>2025-07-22T14:20:34+00:00</published><updated>2025-07-22T14:20:34+00:00</updated><id>https://daheesong.github.io/blog/2025/RRT</id><content type="html" xml:base="https://daheesong.github.io/blog/2025/RRT/"><![CDATA[<p>RRT, Rapidly-exploring Tree는 경로 계획 문제의 폭넓은 범주를 위해 설계된 랜덤화된 자료 구조입니다. RRT는 비홀로노믹 제약 조건과 높은 자유도를 처리할 수 있도록 설계되었으며, 무작위로 선택된 지점을 향해 시스템을 약간씩 이동시키는 제어 입력을 반복적으로 적용함으로써 확장됩니다. 이 글에서는 RRT의 기본 특성부터 구현까지 의논합니다.</p> <p>RRT 이전, 여러 랜덤화 접근법들이 제안되었고, 그 중 랜덤화된 포텐셜 필드 알고리즘과 확률적 로드맵 알고리즘이 일반적인 경로 계획 문제에 성공적으로 적용되었습니다. 하지만 기존 기술들은 표준적인 경로 계획에는 강력하지만, 일반적으로 비홀로노믹 경로 계획 문제에는 자연스럽게 확장되지 않습니다. 상태 공간 표현을 사용하는 이 문제 범주는 운동역학적 경로 계획을 포함하며, 이는 로보틱스에서 일반적이고 중요한 영역입니다. 랜덤화 포텐셜 필드 방식은 좋은 휴리스틱 포텐셜 함수 선택에 크게 의존하는데, 이는 장애물, 운동학적 미분 제약, 동역학 제약이 있는 경우 상당히 어려운 작업이 됩니다. 확률적 로드맵 접근법에서는 구성 공간 내에서 무작위로 구성을 생성하고, 인접한 구성 쌍을 연결하기 위해 지역 계획자를 사용하여 그래프를 구축합니다. 하지만, 일반적으로 이 연결 문제는 비선형 제어기를 설계하는 것만큼이나 어렵습니다. RRT는 비홀로노믹 제약을 가진 문제를 위한 경로 계획에 적합한 랜덤화 자료구조입니다.</p> <p>RRT는 점들을 무작위로 생성하고, 가장 가까운 노드에 연결합니다. 각 정점(vertex)가 생성될 때마다, 그 정점이 장애물 바깥에 위치하는지 확인해야 합니다. 또한, 해당 정점을 가장 가까운 이웃 노드에 연결할 때도 장애물을 피해야합니다. 알고리즘은 생성된 노드가 목표 영역 안에 도달하거나, 사전에 설정한 한계치에 도달하면 종료합니다. 무작위 위치와 이 때 생성된 정점을 연결하는 (chaining) 방식은 사용자의 선택에 달려있습니다. RRT는 구조적으로 정육면체 형태의 그래프를 만듭니다. 이는 각 노드가 가장 가까운 이웃에 연결되기 때문입니다. 이러한 구조는 최적 경로를 찾을 확률을 낮추는 원인이 됩니다. 예를 들자면, 두 점 사이의 대각선을 연결하는 대신, 삼각현의 직각변을 따라 이동하게 되어 경로가 더 길어집니다. 이를 해결하기 위한 알고리즘이 RRT*입니다. RRT의 장점은 빠른 속도와 간단한 구현입니다. 가장 많은 연산이 요구되는 부분은 가장 가까운 이웃 노드를 찾는 작업이며, 이 연산은 생성된 정점의 수에 따라 점점 더 부담이 커집니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/RRT1-480.webp 480w,/assets/img/RRT1-800.webp 800w,/assets/img/RRT1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/RRT1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> source from https://www.linkedin.com/pulse/rrt-rapidly-exploring-random-tree-python-based-animesh-sarkar-xrqrc </div> <p>경로 계획은 일반적으로 메트릭 공간 $X$에서 초기 상태 $x_{init}$에서 목표 영역 $X_{goal} \subset X$ 또는 목표 상태 $x_{goal}$까지의 연속 경로를 탐색하는 것으로 간주됩니다. 여기서 상태 공간(state space)라는 용어는 경로 계획에서 보통 고려되는 것보다 더 일반적인 개념을 나타냅니다. 고정된 장애물 영역 $X_{obs} \subset X$이 존재한다고 가정하며, 이 영역은 피해야합니다. 하지만 $X_{obs}$의 명시적인 표현은 제공되지 않습니다. 주어진 상태가 이 영역에 포함되는지 여부만 확인할 수 있습니다. $X_{obs}$에 있는 상태는 속도 제한, 충돌 위치, 혹은 다양한 해석을 포함할 수 있으며 이는 응용에 따라 다르게 나타냅니다. RRT(Rapidly-exploring Random Tree)는 모든 꼭짓점이 자유 상태 공간 $X_{free} \subset X$ (즉, $X_{obs}$의 여집합)에 속하도록 구성된다. 또한 RRT의 각 간선은 전적으로 $X_{free}$ 내에 위치한 경로에 해당한다. 상태 전이 방정식은 비홀로노믹 제약을 나타내기 위해 $\dot{x} = f(x, u)$ 형태로 정의됩니다. 벡터 $u$는 입력의 집합 $U$에서 선택되며, $\dot{x}$는 시간에 따른 상태의 미분을 의미합니다. 고정된 시간 간격 $\Delta t$ 동안 함수 $f$를 적분함으로써, 초기 상태 $x$와 입력 $u$에 대해 다음 상태 $x_{new}$를 구할 수 있습니다. 홀로노믹의 경우, $f(x, u) = u$로 정의할 수 있으며, $|u| \leq 1$로 제한됩니다. 이는 모든 방향으로 시스템을 이동시킬 수 있음을 의미합니다. 반면, 비홀로노믹 문제에서는 선택된 $f$로 인해 다음 상태가 제약을 받습니다:</p> <p>주어진 초기 상태 상태 $x_{init}$에 대해, 꼭짓점 수가 $K$인 RRT $\mathcal{T}$는 다음과 같은 알고리즘으로 생성됩니다:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
<span class="nc">GENERATE_RRT</span><span class="p">(</span><span class="n">x_init</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">𝒯</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">x_init</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">K</span> <span class="n">do</span>
        <span class="n">x_rand</span> <span class="o">=</span> <span class="nc">RANDOM_STATE</span><span class="p">()</span>
        <span class="n">x_near</span> <span class="o">=</span> <span class="nc">NEAREST_NEIGHBOR</span><span class="p">(</span><span class="n">x_rand</span><span class="p">,</span> <span class="n">𝒯</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="nc">SELECT_INPUT</span><span class="p">(</span><span class="n">x_rand</span><span class="p">,</span> <span class="n">x_near</span><span class="p">)</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="nc">NEW_STATE</span><span class="p">(</span><span class="n">x_near</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">𝒯</span><span class="p">.</span><span class="nf">add_vertex</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">𝒯</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">x_near</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">𝒯</span>

</code></pre></div></div> <p>ρ는 사태 공간 상의 거리 측정 기준을 나타내며, 트리 $\mathcal{T}$의 첫 번째 꼭짓점은 $x_{init} \in X_{free}$입니다. 각 반족에서 무작위 상태 $x_{rand}$는 유한한 공간이라 가정된 $X$에서 선택되며, ρ를 기준으로 $x_{rand}$에서 가장 가까운 꼭짓점 $x_{near}$를 찾습니다. 마지막으로, $x_{near}$에서 $x_{rand}$까지 거리를 최소화하는 입력 $u$를 선택하여 $x_{new}$가 $x_{free}$ 내에 있도록 합니다.</p> <p>충돌 검출은 V-Clip같은 점진적 방법으로 수행될 수 있습니다. NEW STATE는 가능한 새 상태를 평가하기 위해 각 입력 $u$에 대해 호출되며 $U$가 유한하지 않은 경우 이산화하거나 최적화 기법을 사용할 수 있습니다. 입력 $u$를 적용하여 얻은 새 상태 $x_{new}$는 트리에 꼭짓점으로 추가되고 간선 $(x_{near}, x_{new})$는 $u$와 함께 기록됩니다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotpib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">random</span>

<span class="c1"># initial setting
</span><span class="n">X_LIMITS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">Y_LIMITS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">STEP_SIZE</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">NUM_VERTICES</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">GOAL_RADIUS</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">random_state</span><span class="p">():</span>
    <span class="nf">return</span><span class="p">(</span>
        <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">X_LIMITS</span><span class="p">),</span>
        <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">Y_LIMITS</span><span class="p">)</span>
        <span class="p">)</span>

<span class="c1">#find nearest node
</span><span class="k">def</span> <span class="nf">nearest_vertex</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x_rand</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">min</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span><span class="nf">distance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x_rand</span><span class="p">))</span>

<span class="c1">#calc new state (simple euler integration)
</span><span class="k">def</span> <span class="nf">new_state</span><span class="p">(</span><span class="n">x_near</span><span class="p">,</span> <span class="n">x_rand</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">STEP_SIZE</span><span class="p">):</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x_rand</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x_near</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_near</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">/</span> <span class="n">norm</span>
    <span class="n">x_new</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x_near</span><span class="p">)</span> <span class="o">+</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">step_size</span>
    <span class="k">return</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>

<span class="c1">#RRT
</span><span class="k">def</span> <span class="nf">generate_rrt</span><span class="p">(</span><span class="n">x_init</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">NUM_VERTICES</span><span class="p">):</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_init</span><span class="p">]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range </span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">x_rand</span> <span class="o">=</span> <span class="nf">random_state</span><span class="p">()</span>
        <span class="n">x_near</span> <span class="o">=</span> <span class="nf">nearest_vertex</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="n">x_rand</span><span class="p">)</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="nf">new_state</span><span class="p">(</span><span class="n">x_near</span><span class="p">,</span> <span class="n">x_rand</span><span class="p">)</span>
        <span class="n">tree</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">edges</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">x_near</span><span class="p">,</span> <span class="n">x_new</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">tree</span><span class="p">,</span> <span class="n">edges</span>
    
<span class="k">def</span> <span class="nf">plot_rrt</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">x_init</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="nf">for </span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="sh">'</span><span class="s">b-</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x_init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="sh">'</span><span class="s">ro</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Start</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">RRT in 2D Space</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="n">X_LIMITS</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">ylim</span><span class="p">(</span><span class="n">Y_LIMITS</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">gca</span><span class="p">().</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
        
<span class="k">if</span> <span class="n">__name__</span> <span class="o">=</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">x_init</span> <span class="o">=</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">tree</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="nf">generate_rrt</span><span class="p">(</span><span class="n">x_init</span><span class="p">)</span>
    <span class="nf">plot_rrt</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">x_init</span><span class="p">)</span>

</code></pre></div></div> <p>쉽게 다시 한 번 정리하자면 RRT는 초기 위치를 안 상태에서, 무작위의 점들을 발생시키고 그 점들 중 하나로 이동합니다. 만약 장애물이 있다면 다시 한 번 무작위 점들 중 하나로 돌아오고, 이를 반복하여 목적 지점까지 도착하게하는 알고리즘입니다.</p> <p>Reference: @article{LaValle1998RapidlyexploringRT, title={Rapidly-exploring random trees : a new tool for path planning}, author={Steven M. LaValle}, journal={The annual research report}, year={1998}, url={https://api.semanticscholar.org/CorpusID:14744621} }</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="path_planning"/><summary type="html"><![CDATA[reviews the basic of RRT]]></summary></entry><entry><title type="html">Rapidly-Exploring Random Tree Star (RRT*)</title><link href="https://daheesong.github.io/blog/2025/OptimizedRRT/" rel="alternate" type="text/html" title="Rapidly-Exploring Random Tree Star (RRT*)"/><published>2025-07-22T14:20:34+00:00</published><updated>2025-07-22T14:20:34+00:00</updated><id>https://daheesong.github.io/blog/2025/OptimizedRRT</id><content type="html" xml:base="https://daheesong.github.io/blog/2025/OptimizedRRT/"><![CDATA[<p>RRT<em>는 RRT의 최적화된 버전입니다. 노드의 수가 무한에 가까워질수록, RRT</em> 알고리즘은 목표 지점까지의 최단 경로를 제공하게 됩니다. 현실적으로는 실현 불가능하더라도, 이 문장은 알고리즘이 최단 경로를 생성하는 방향으로 작동한다는 것을 의미합니다. RRT*의 기본 원리는 RRT와 동일하지만, 두 가지 기능이 추가되어 결과는 크게 발전합니다.</p> <p>첫 번째, RRT*는 각 정점이 부모 정점으로부터 이동한 거리를 기록합니다. 이를 cost()라고 하며, 그래프에서 가장 가까운 노드가 찾아진 후, 새로운 노드로부터 일정 반경 내에 있는 이웃 노드들이 검사됩니다. 이 때, 근접 노드보다 더 적은 cost()를 지닌 노드가 발견되면, 그 근접 노드를 더 저렴한 새로운 노드로 대체하게 됩니다. 이 기능의 효과는 RRT의 정육면체 구조가 아닌 트리 구조의 부채꼴로 뻗어 나가는 가지들에서 확인할 수 있습니다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/RRTs1-480.webp 480w,/assets/img/RRTs1-800.webp 800w,/assets/img/RRTs1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/RRTs1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> source from https://www.linkedin.com/pulse/rrt-rapidly-exploring-random-tree-python-based-animesh-sarkar-xrqrc </div> <p>두 번째 차이점은 트리의 재배선(rewiring)입니다. 정점이 가장 저렴한 이웃 노드에 연결된 후, 이웃 노드들이 다시 한 번 검사됩니다. 이웃 노드가 새로 추가된 정점에 연결되었을 때, cost()가 줄어든다면, 해당 이웃 노드는 새 정점으로 다시 연결됩니다. 이 방법 덕분에 경로는 부드럽게 연결됩니다.</p> <p>RRT는 매우 직선적인 경로를 만들언애며, 생성된 그래프는 RRT의 그래프와 다릅니다. 장애물이 많은 복잡한 환경에서 최적의 경로를 찾을 때, RRT<em>의 구조는 매우 유용합니다. 목적지가 변경되더라도, 원래 생성된 그래프는 여전히 해당 영역 내 대부분의 위치에서 가장 빠른 경로를 나타내므로 활용이 가능합니다. 그럼에도 불구하고 RRT</em>는 성능 저하라는 단점을 가지고 있습니다. 이웃 노드를 검사하고 그래프를 재배선해야 하기 때문입니다. 장애물 회피 여부를 확인하는 데에 드는 많은 소요 시간이 들지만, 생성된 경로의 우수성을 부정할 수 없습니다.</p> <p>다음은 RRT*의 pseudo 코드입니다:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
<span class="n">Rad</span> <span class="o">=</span> <span class="n">r</span>
<span class="nc">G</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">)</span>
<span class="n">For</span> <span class="n">itr</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">Xnew</span> <span class="o">=</span> <span class="nc">RandomPosition</span><span class="p">()</span>
    <span class="n">If</span> <span class="nc">Obstacle</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span> <span class="o">==</span> <span class="bp">True</span><span class="p">,</span> <span class="k">try</span> <span class="n">again</span>
    <span class="n">Xnearest</span> <span class="o">=</span> <span class="nc">Nearest</span><span class="p">(</span><span class="nc">G</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">),</span> <span class="n">Xnew</span><span class="p">)</span>
    <span class="nc">Cost</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span> <span class="o">=</span> <span class="nc">Distance</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">Xnearest</span><span class="p">)</span>
    <span class="n">Xbest</span><span class="p">,</span> <span class="n">Xneighbors</span> <span class="o">=</span> <span class="nf">findNeighbors</span><span class="p">(</span><span class="nc">G</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">),</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">Rad</span><span class="p">)</span>
    <span class="n">Link</span> <span class="o">=</span> <span class="nc">Chain</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">Xbest</span><span class="p">)</span>
    <span class="n">For</span> <span class="n">x</span><span class="err">`</span> <span class="ow">in</span> <span class="n">Xneighbors</span>
        <span class="n">If</span> <span class="nc">Cost</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span> <span class="o">+</span> <span class="nc">Distance</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span><span class="n">x</span><span class="sb">`) &lt; Cost(x`</span><span class="p">)</span>
            <span class="nc">Cost</span><span class="p">(</span><span class="n">x</span><span class="sb">`) = Cost(Xnew) + Distance(Xnew, x`</span><span class="p">)</span>
            <span class="nc">Parent</span><span class="p">(</span><span class="n">x</span><span class="err">`</span><span class="p">)</span> <span class="o">=</span> <span class="n">Xnew</span>
            <span class="n">G</span> <span class="o">+=</span> <span class="p">{</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">x</span><span class="err">`</span><span class="p">}</span>
    <span class="n">G</span> <span class="o">+=</span> <span class="n">Link</span>
<span class="k">return</span> <span class="n">G</span>

</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="mf">0.0</span>
        
<span class="k">class</span> <span class="nc">RRTStar</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">map_area</span><span class="p">,</span> <span class="n">obstacle_lst</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">goal_sample_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">goal</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="o">*</span><span class="n">goal</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">map_area</span> <span class="o">=</span> <span class="n">map_area</span>
        <span class="n">self</span><span class="p">.</span><span class="n">obstacle_lst</span> <span class="o">=</span> <span class="n">obstacle_lst</span>
        <span class="n">self</span><span class="p">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">goal_sample_rate</span> <span class="o">=</span> <span class="n">goal_sample_rate</span>
        <span class="n">slef</span><span class="p">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">start</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">search_radius</span> <span class="o">=</span> <span class="mf">5.0</span>
        
    <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">max_iter</span><span class="p">):</span>
                <span class="n">rnd</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">sample</span><span class="p">()</span>
                <span class="n">nearest_node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_nearest_node</span><span class="p">(</span><span class="n">rnd</span><span class="p">)</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">steer</span><span class="p">(</span><span class="n">nearest_node</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_collision</span><span class="p">(</span><span class="n">new_node</span><span class="p">):</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find_neighbors</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                    <span class="n">min_cost_node</span> <span class="o">=</span> <span class="n">nearest_node</span>
                    <span class="n">min_cost</span> <span class="o">=</span> <span class="n">nearest_node</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">nearest_node</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                        <span class="n">cost</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_cllision_edge</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">:</span>
                            <span class="n">min_cost</span> <span class="o">=</span> <span class="n">cost</span>
                            <span class="n">min_cost_node</span> <span class="o">=</span> <span class="n">neighbor</span>
                            
                    <span class="n">new_node</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">min_cost</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">min_cost_node</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">node_lst</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                            
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span> <span class="c1">#Rewire
</span>                        <span class="n">cost_through_new</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">cost_through_new</span> <span class="o">&lt;</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">cost</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_collision_edge</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">):</span>
                                <span class="n">neighbor</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">new_node</span>
                                <span class="n">neighbor</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">cost_through_new</span>
                    
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">extract_path</span><span class="p">()</span>
                                
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">goal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">return</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                    
    <span class="k">def</span> <span class="nf">get_nearest_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                                    
    <span class="k">def</span> <span class="nf">steer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">atan2</span><span class="p">(</span><span class="n">to_node</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">from_node</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">to_node</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">from_node</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">step_size</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">from_node</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
                        <span class="n">from_node</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_node</span>
                                    
    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="nf">for </span><span class="p">(</span><span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">obstacle_list</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">ox</span> <span class="o">-</span> <span class="n">node</span><span class="p">.</span><span class="n">x</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">oy</span> <span class="o">-</span> <span class="n">node</span><span class="p">.</span><span class="n">y</span>
            <span class="k">if</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

     <span class="k">def</span> <span class="nf">is_collision_edge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">n1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="n">steps</span> <span class="o">*</span> <span class="p">(</span><span class="n">n2</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">n1</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">n1</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="n">steps</span> <span class="o">*</span> <span class="p">(</span><span class="n">n2</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">n1</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_collision</span><span class="p">(</span><span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="nf">hypot</span><span class="p">(</span><span class="n">n1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">n2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">n1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">n2</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_neighbors</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">search_radius</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">node_list</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">extract_path</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">last_node</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">goal</span><span class="p">))</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[(</span><span class="n">last_node</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">last_node</span><span class="p">.</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">last_node</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="n">last_node</span> <span class="o">=</span> <span class="n">last_node</span><span class="p">.</span><span class="n">parent</span>
            <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">last_node</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">last_node</span><span class="p">.</span><span class="n">y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                                
   <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">node_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">node</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">y</span><span class="p">],</span> <span class="sh">"</span><span class="s">-g</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">for </span><span class="p">(</span><span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">obstacle_list</span><span class="p">:</span>
            <span class="n">circle</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nc">Circle</span><span class="p">((</span><span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">.</span><span class="nf">add_patch</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="sh">'</span><span class="s">-r</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="sh">"</span><span class="s">ro</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">goal</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">goal</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="sh">"</span><span class="s">bo</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">RRT* Path Planning</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>                                             
                  

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
    <span class="nf">map_area</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="n">obstacle</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#predefined
</span>    
    <span class="n">rrt_star</span> <span class="o">=</span> <span class="nc">RRTStar</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">map_area</span><span class="p">,</span> <span class="n">obstacles</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">rrt_star</span><span class="p">.</span><span class="nf">plan</span><span class="p">()</span>
    <span class="n">rrt_star</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                                                
</code></pre></div></div> <p>Reference: @misc{karaman2011samplingbasedalgorithmsoptimalmotion, title={Sampling-based Algorithms for Optimal Motion Planning}, author={Sertac Karaman and Emilio Frazzoli}, year={2011}, eprint={1105.1186}, archivePrefix={arXiv}, primaryClass={cs.RO}, url={https://arxiv.org/abs/1105.1186}, }</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="path_planning"/><summary type="html"><![CDATA[reviews the basic of RRT*]]></summary></entry><entry><title type="html">An Overview of Path Planning</title><link href="https://daheesong.github.io/blog/2025/an-overview-of-path-planning/" rel="alternate" type="text/html" title="An Overview of Path Planning"/><published>2025-07-20T09:40:30+00:00</published><updated>2025-07-20T09:40:30+00:00</updated><id>https://daheesong.github.io/blog/2025/an-overview-of-path-planning</id><content type="html" xml:base="https://daheesong.github.io/blog/2025/an-overview-of-path-planning/"><![CDATA[<p>Path planning(경로 계획)의 개념은 다음과 같습니다: 환경 정보를 얼마나 알고 있는가에 따라 환경 정보가 완전히 알려진 global path planning과 부분적으로 환경 정보가 알려진 local path planning으로 나눌 수 있습니다. 또한 환경 내 장애물이 움직이는지의 여부에 따라 장애물이 정적인 static planning과 장애물이 동적인 dynamic planning으로 나뉠 수 있습니다. 그리고, 모바일 로봇 시스템에서 제어 가능한 변수의 수가 로봇의 attitude 공간 차원보다 작은지의 여부에 따라, 제어 가능한 자유도가 전체 자세 공간보다 같거나 많은 (ex, 드론, x-y평면에서 움직이는 로봇 팔) holonomic system의 운동 계획, 그와 반대 되는 non-holonomic system의 운동 계획으로 나뉠 수 있습니다.</p> <p>Global path planning은 시작점에서 목표지점까지의 순수한 기하학적 경로를 다룹니다. Local path planning은 obstacle avoidance planning, dynamic path planning, real-time navigation planning이라고도 불립니다. 장애물을 탐지하고 움직이는 장애물의 괘적을 추적하며 다음 위치를 예측하는데 초점을 맞춥니다. 결과, 현재 존재하는 충돌 위험과 잠재적인 충돌 위험이 포함된 지도를 생성하게 됩니다.</p> <p>Path planning을 수행하기 위해서는, 우선 모바일 로봇의 이동 환경 모델을 구축해야 합니다. 환경은 보통 정적(static)과 동적(dynamic) 환경으로 나눌 수 있습니다. 정적 환경은 상대적으로 단순하지만, 대부분의 환경은 실시간으로 변화하는 동적 환경입니다. 이러한 특성은 경로 계획 알고리즘에 높은 실시간성과 robustness를 요구합니다. 현재 사용되는 환경 모델링 방법은 주로 모바일 로봇의 주변 환경 정보를 수집하여, map subsystem을 통해 기하학적/위상학적 특성을 갖춘 지도상에 표현하는 것입니다. 이 지도에는 도로 혹은 사물간의 연결 관계가 포함됩니다. 가장 단순한 지도 생성 방법은 항공 사진에서 이를 추출하여 라벨링하는 것 입니다. 동적 환경에는 MOT(Multi-object tracking) 또는 DATMO (Detection and tracking moving object) 서브시스템이 사용되어, 로봇 주변의 장애물의 위치나 방향을 탐지 및 추적합니다.</p> <p>전통적인 환경 모델링 방법은 다음과 같습니다:</p> <ul> <li>Multi-object tracking: 센서 데이터를 분할하고 분할된 데이터를 장애물에 연결하여, 대상별 위치 추정을 위해 할당된 데이터를 평균 처리하고 필터(ex, Kalman Filter or Particle Filter)로 위치를 갱신한다.</li> <li>Model based Approach: 센서의 물리 모델과 객체의 기하학 모델을 활용하여 필터(ex, Particle filter)로 직접 데이터를 해석한다.</li> <li>Stereo Vision based method: 스테레오 이미지에서 제공되는 색상 및 깊이 정보를 이용해 움직이는 장애물을 탐지 및 추적한다. ESS는 전방 카메라의 동기화된 영상 만으로 장애물을 탐지하는 기법을 제안한다.</li> <li>Raster Map based method: occupancy grid map을 먼저 구축하고, 분할, 연관, 필터링 단계를 통해 객체 수준의 장면 표현을 제공한다.</li> <li>Sensor fusion: 다양한 센서를 융합하여 환경 인식을 향상한다.</li> <li>Deep Laerning: DNN을 통해 이동 장애물의 위치 및 기하학적 특징을 추출하고, 현재 카메라 데이터를 바탕으로 미래 상태를 추적한다.</li> <li>V2X: Vehicle to Everything은 차량 간, 차량과 인프라 간, 차량과 보행자 간, 차량과 네트워크 간 통신을 가능케 함으로서 실시간 도로 상황, 정보, 보행자 정보 등을 알 수 있으며, V2V(ehicle), V2I(nfra), V2P(erson), V2N(etwork)을 포함한다.</li> </ul> <p>Path planning 알고리즘은 크게 세 가지로 나뉩니다. 1) 지도 기반의 전통적인 경로 계획 알고리즘 (Dijkstra, A*), 2) 생물 모방 기반의 지능형 경로 계획 알고리즘 (PSO, 유전자 알고리즘, 강화 학습), 3) 샘플링 기반의 경로 계획 알고리즘 (RRT).</p> <p>지도 기반 전통 경로 계획 알고리즘은 대표적으로 5가지가 있습니다: Dijkstra, a<em>, D</em>, LPA<em>, D</em> Lite. 이들은 A* 계열로 알고리즘을 실행하기 전 환경 모델을 반드시 구축해야합니다.</p> <p>Dijkstra 알고리즘은 탐욕적 원칙을 기반으로 하여 노드를 하나씩 순차적으로 탐색하고, 완화(relaxation) 방법으로 경로를 최적화합니다. 최종적으로 최적 경로를 리스트에 저장하여 최적 경로 문제를 해결하는 방식으로, 지도 데이터가 작을 때는 효과적이지만, 데이터 양이 많을 경우 성능이 급격히 떨어집니다. 우선순위 큐와 역 N-트리를 결합하면 성능이 향상될 수 있으며, 제한된 범위 내에서의 탐색 방식을 도입하면 탐색 범위 및 횟수를 줄여 검색 효율을 향상할 수 있습니다.</p> <p>A* 알고리즘은 Dijkstra 알고리즘을 개선한 heuristic 탐색 알고리즘입니다. 추정 함수를 추가하여, 탐색 위치와 목표 지점 간의 거리를 예측함으로서 탐색 방향을 목표 지점 쪽으로 우선 유도 합니다. 기본 함수 형태는 f(x) = g(x) + h(x)입니다. g(x)는 시작점에서 현재 노드 x까지의 실제 거리를 의미하며, h(x)는 현재 노드 x에서 목표점까지의 최소 거리 추정값입니다. Dijkstra에 비해 탐색 횟수가 줄고 속도가 빨라서 널리 사용됩니다. 또한, 목표 지점 근처로 갈수록 탐색 범위가 좁아집니다.</p> <p>D* 알고리즘은 Dynamic A* 알고리즘입니다. 목표점에서 시작점 방향으로 탐색하는 Reverse Incremental Search 방식을 사용하며, 도중 장애물이 나타나면, 기존 거리 정보를 재사용하여 전체 경로를 재계산하지 않고 부분만 갱신합니다. H(x) = H(y) + C(y,x) 공식을 사용하며 H(y)는 y지점에서 목표까지의 거리이고, C(y,x)는 y지점에서 x지점까지의 거리를 의미합니다.</p> <p>LPA* 알고리즘은 Life Planning A*의 약어로, Increasement heuristic serarch 알고리즘입니다. 시작점에서 탐색을 시작하며, key값을 기준으로 탐색을 진행합니다. 목표 지점이 다음 탐색 대상이 되면 계획을 완료하고, Key 값은 휴리스틱 요소를 포함하여 탐색 방향에 영향을 줍니다. 동적 환경에서도 이전 탐색에서 얻은 G 값을 활용하여 전체 환경을 재 탐색하지 않고 빠르게 경로 재계획 가능합니다. G(n)은 시작점에서 현재 노드까지의 거리이며, RHS(n)은 min(g(n)+c(n,n’)) (n’은 n의 부모 노드), h(n, goal)은 목표에 대한 휴리스틱 값을 의미합니다. 먼저 K1 값을 비교하고, K1이 작으면 해당 노드를 우선 탐색, K1 = K2이면 K2가 더 작은 노드를 우선하며 탐색합니다.</p> <p>D* Lite 알고리즘은 LPA*을 기반으로 제안한 경로 계획 알고리즘입니다. Key 계산 시 목표점(goal) 대신 시작점을 기준으로 한 정보를 사용하며, 알고리즘은 역방향 탐색으로 시작하여 최적 경로를 찾고, 동적 장애물이 나타나면 국지적인 범위에서 탐색을 재시작합니다. 경로 탐색 정보를 재활용할 수 있고, 장애물로 인해 기준 경로의 사용이 불가할 시, 현재 위치에서 빠르게 최적 경로 재계획이 가능합니다.</p> <p>생물 기반의 경로 계획 알고리즘으로는 신경망, 개미 군집 알고리즘, 늑대 군집 알고리즘, 유전 알고리즘 등이 있습니다. 유전 알고리즘은 자연 선택과 다윈의 진화 메커니즘을 모방하여 최적 해를 탐색하는 알고리즘입니다. 주요 특징은 함수의 도함수나 연속성의 제약 없이 구조적 개체를 직접 다룰 수 있으며, 내재된 병렬성과 뛰어난 전역 최적화 능력을 갖추고 있다는 것입니다. 확률 기반의 방식으로 명확한 규칙 없이도 최적 해 탐색이 가능합니다. 신경망 알고리즘은 많은 수의 노드(또는 뉴런)로 구성된 연산 모델로, 각 노드는 활성화 함수라 불리는 특정 출력 함수를 가지며, 노드 간 연결은 가중치를 통해 신호 강도를 조절한다. 이 가중치는 인공 신경망의 기억에 해당합니다. 개미 군집 알고리즘은 현재 널리 사용되는 지능형 알고리즘 중 하나지만, 반복 횟수가 많고 수렴 속도가 느리며 국소 최적 해에 빠지기 쉽다는 단점이 있습니다. fuzzy 알고리즘을 결합하여 수렴 속도를 개선하거나, 유전 알고리즘과의 결합을 통해 최적 경로를 도출하는 방식 등이 있습니다.</p> <p>샘플링 기반 경로 계획 알고리즘은 확률적 로드맵(PRM)과 빠른 탐색 랜덤 트리(RRT)가 대표적입니다. PRM 알고리즘은 경로 공간에서 무작위로 N개의 노드를 선택하고, 각 노드를 연결한 뒤 장애물과 충돌하는 연결을 제거하여 실행 가능한 경로를 생성하는 방식입니다. 샘플링 포인트 수가 적거나 배치가 비효율적이면 알고리즘의 완전성이 떨어지지만, 샘플링을 추가하면 보완할 수 있습니다. 따라서 PRM은 확률적 완전성은 있지만 최적성은 없습니다. RRT (Rapidly exploring random tree)는 경로 공간의 모델링이 필요 없고 탐색 범위가 넓으며 미지 영역을 광범위하게 탐색할 수 있는 장점이 있습니다. 하지만 계산 비용이 크며, 이를 해결하기 위해 다양한 변형 알고리즘 (Goal-Bias RRT, Bi-RRT, RRT-Connect, Extend RRT, Local-Tree-RRT, Dynamic RRT)이 존재합니다.</p> <p>References: @article{Tang_2021, doi = {10.1088/1755-1315/804/2/022024}, url = {https://dx.doi.org/10.1088/1755-1315/804/2/022024}, year = {2021}, month = {jul}, publisher = {IOP Publishing}, volume = {804}, number = {2}, pages = {022024}, author = {Tang, Zhuozhen and Ma, Hongzhong}, title = {An overview of path planning algorithms}, journal = {IOP Conference Series: Earth and Environmental Science}, abstract = {This paper reviews the basic concepts of path planning, classifies environmental modeling methods, analyzes the significance of V2X environment modeling, and summarizes the existing path planning algorithms. Different algorithm can be adjusted in time according to different environments to improve the efficiency of path planning. In addition, according to the advantages and disadvantages of different algorithms, each algorithm is fused, which can effectively avoid the shortcomings of each algorithm and improve the efficiency of the planning algorithm.} }</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="path_planning"/><summary type="html"><![CDATA[reviews the basic concepts of path planning and summarizes the existing path planning algorithms]]></summary></entry></feed>