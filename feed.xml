<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://daheesong.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://daheesong.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-24T06:24:13+00:00</updated><id>https://daheesong.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Rapidly-Exploring Random Trees</title><link href="https://daheesong.github.io/blog/2025/RRT/" rel="alternate" type="text/html" title="Rapidly-Exploring Random Trees"/><published>2025-07-22T14:20:34+00:00</published><updated>2025-07-22T14:20:34+00:00</updated><id>https://daheesong.github.io/blog/2025/RRT</id><content type="html" xml:base="https://daheesong.github.io/blog/2025/RRT/"><![CDATA[<p>RRT, Rapidly-exploring TreeëŠ” ê²½ë¡œ ê³„íš ë¬¸ì œì˜ í­ë„“ì€ ë²”ì£¼ë¥¼ ìœ„í•´ ì„¤ê³„ëœ ëœë¤í™”ëœ ìë£Œ êµ¬ì¡°ì…ë‹ˆë‹¤. RRTëŠ” ë¹„í™€ë¡œë…¸ë¯¹ ì œì•½ ì¡°ê±´ê³¼ ë†’ì€ ììœ ë„ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„ë˜ì—ˆìœ¼ë©°, ë¬´ì‘ìœ„ë¡œ ì„ íƒëœ ì§€ì ì„ í–¥í•´ ì‹œìŠ¤í…œì„ ì•½ê°„ì”© ì´ë™ì‹œí‚¤ëŠ” ì œì–´ ì…ë ¥ì„ ë°˜ë³µì ìœ¼ë¡œ ì ìš©í•¨ìœ¼ë¡œì¨ í™•ì¥ë©ë‹ˆë‹¤. ì´ ê¸€ì—ì„œëŠ” RRTì˜ ê¸°ë³¸ íŠ¹ì„±ë¶€í„° êµ¬í˜„ê¹Œì§€ ì˜ë…¼í•©ë‹ˆë‹¤.</p> <p>RRT ì´ì „, ì—¬ëŸ¬ ëœë¤í™” ì ‘ê·¼ë²•ë“¤ì´ ì œì•ˆë˜ì—ˆê³ , ê·¸ ì¤‘ ëœë¤í™”ëœ í¬í…ì…œ í•„ë“œ ì•Œê³ ë¦¬ì¦˜ê³¼ í™•ë¥ ì  ë¡œë“œë§µ ì•Œê³ ë¦¬ì¦˜ì´ ì¼ë°˜ì ì¸ ê²½ë¡œ ê³„íš ë¬¸ì œì— ì„±ê³µì ìœ¼ë¡œ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ê¸°ì¡´ ê¸°ìˆ ë“¤ì€ í‘œì¤€ì ì¸ ê²½ë¡œ ê³„íšì—ëŠ” ê°•ë ¥í•˜ì§€ë§Œ, ì¼ë°˜ì ìœ¼ë¡œ ë¹„í™€ë¡œë…¸ë¯¹ ê²½ë¡œ ê³„íš ë¬¸ì œì—ëŠ” ìì—°ìŠ¤ëŸ½ê²Œ í™•ì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒíƒœ ê³µê°„ í‘œí˜„ì„ ì‚¬ìš©í•˜ëŠ” ì´ ë¬¸ì œ ë²”ì£¼ëŠ” ìš´ë™ì—­í•™ì  ê²½ë¡œ ê³„íšì„ í¬í•¨í•˜ë©°, ì´ëŠ” ë¡œë³´í‹±ìŠ¤ì—ì„œ ì¼ë°˜ì ì´ê³  ì¤‘ìš”í•œ ì˜ì—­ì…ë‹ˆë‹¤. ëœë¤í™” í¬í…ì…œ í•„ë“œ ë°©ì‹ì€ ì¢‹ì€ íœ´ë¦¬ìŠ¤í‹± í¬í…ì…œ í•¨ìˆ˜ ì„ íƒì— í¬ê²Œ ì˜ì¡´í•˜ëŠ”ë°, ì´ëŠ” ì¥ì• ë¬¼, ìš´ë™í•™ì  ë¯¸ë¶„ ì œì•½, ë™ì—­í•™ ì œì•½ì´ ìˆëŠ” ê²½ìš° ìƒë‹¹íˆ ì–´ë ¤ìš´ ì‘ì—…ì´ ë©ë‹ˆë‹¤. í™•ë¥ ì  ë¡œë“œë§µ ì ‘ê·¼ë²•ì—ì„œëŠ” êµ¬ì„± ê³µê°„ ë‚´ì—ì„œ ë¬´ì‘ìœ„ë¡œ êµ¬ì„±ì„ ìƒì„±í•˜ê³ , ì¸ì ‘í•œ êµ¬ì„± ìŒì„ ì—°ê²°í•˜ê¸° ìœ„í•´ ì§€ì—­ ê³„íšìë¥¼ ì‚¬ìš©í•˜ì—¬ ê·¸ë˜í”„ë¥¼ êµ¬ì¶•í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ, ì¼ë°˜ì ìœ¼ë¡œ ì´ ì—°ê²° ë¬¸ì œëŠ” ë¹„ì„ í˜• ì œì–´ê¸°ë¥¼ ì„¤ê³„í•˜ëŠ” ê²ƒë§Œí¼ì´ë‚˜ ì–´ë µìŠµë‹ˆë‹¤. RRTëŠ” ë¹„í™€ë¡œë…¸ë¯¹ ì œì•½ì„ ê°€ì§„ ë¬¸ì œë¥¼ ìœ„í•œ ê²½ë¡œ ê³„íšì— ì í•©í•œ ëœë¤í™” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.</p> <p>RRTëŠ” ì ë“¤ì„ ë¬´ì‘ìœ„ë¡œ ìƒì„±í•˜ê³ , ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œì— ì—°ê²°í•©ë‹ˆë‹¤. ê° ì •ì (vertex)ê°€ ìƒì„±ë  ë•Œë§ˆë‹¤, ê·¸ ì •ì ì´ ì¥ì• ë¬¼ ë°”ê¹¥ì— ìœ„ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤. ë˜í•œ, í•´ë‹¹ ì •ì ì„ ê°€ì¥ ê°€ê¹Œìš´ ì´ì›ƒ ë…¸ë“œì— ì—°ê²°í•  ë•Œë„ ì¥ì• ë¬¼ì„ í”¼í•´ì•¼í•©ë‹ˆë‹¤. ì•Œê³ ë¦¬ì¦˜ì€ ìƒì„±ëœ ë…¸ë“œê°€ ëª©í‘œ ì˜ì—­ ì•ˆì— ë„ë‹¬í•˜ê±°ë‚˜, ì‚¬ì „ì— ì„¤ì •í•œ í•œê³„ì¹˜ì— ë„ë‹¬í•˜ë©´ ì¢…ë£Œí•©ë‹ˆë‹¤. ë¬´ì‘ìœ„ ìœ„ì¹˜ì™€ ì´ ë•Œ ìƒì„±ëœ ì •ì ì„ ì—°ê²°í•˜ëŠ” (chaining) ë°©ì‹ì€ ì‚¬ìš©ìì˜ ì„ íƒì— ë‹¬ë ¤ìˆìŠµë‹ˆë‹¤. RRTëŠ” êµ¬ì¡°ì ìœ¼ë¡œ ì •ìœ¡ë©´ì²´ í˜•íƒœì˜ ê·¸ë˜í”„ë¥¼ ë§Œë“­ë‹ˆë‹¤. ì´ëŠ” ê° ë…¸ë“œê°€ ê°€ì¥ ê°€ê¹Œìš´ ì´ì›ƒì— ì—°ê²°ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ êµ¬ì¡°ëŠ” ìµœì  ê²½ë¡œë¥¼ ì°¾ì„ í™•ë¥ ì„ ë‚®ì¶”ëŠ” ì›ì¸ì´ ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ìë©´, ë‘ ì  ì‚¬ì´ì˜ ëŒ€ê°ì„ ì„ ì—°ê²°í•˜ëŠ” ëŒ€ì‹ , ì‚¼ê°í˜„ì˜ ì§ê°ë³€ì„ ë”°ë¼ ì´ë™í•˜ê²Œ ë˜ì–´ ê²½ë¡œê°€ ë” ê¸¸ì–´ì§‘ë‹ˆë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ì•Œê³ ë¦¬ì¦˜ì´ RRT*ì…ë‹ˆë‹¤. RRTì˜ ì¥ì ì€ ë¹ ë¥¸ ì†ë„ì™€ ê°„ë‹¨í•œ êµ¬í˜„ì…ë‹ˆë‹¤. ê°€ì¥ ë§ì€ ì—°ì‚°ì´ ìš”êµ¬ë˜ëŠ” ë¶€ë¶„ì€ ê°€ì¥ ê°€ê¹Œìš´ ì´ì›ƒ ë…¸ë“œë¥¼ ì°¾ëŠ” ì‘ì—…ì´ë©°, ì´ ì—°ì‚°ì€ ìƒì„±ëœ ì •ì ì˜ ìˆ˜ì— ë”°ë¼ ì ì  ë” ë¶€ë‹´ì´ ì»¤ì§‘ë‹ˆë‹¤.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/RRT1-480.webp 480w,/assets/img/RRT1-800.webp 800w,/assets/img/RRT1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/RRT1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> source from https://www.linkedin.com/pulse/rrt-rapidly-exploring-random-tree-python-based-animesh-sarkar-xrqrc </div> <p>ê²½ë¡œ ê³„íšì€ ì¼ë°˜ì ìœ¼ë¡œ ë©”íŠ¸ë¦­ ê³µê°„ $X$ì—ì„œ ì´ˆê¸° ìƒíƒœ $x_{init}$ì—ì„œ ëª©í‘œ ì˜ì—­ $X_{goal} \subset X$ ë˜ëŠ” ëª©í‘œ ìƒíƒœ $x_{goal}$ê¹Œì§€ì˜ ì—°ì† ê²½ë¡œë¥¼ íƒìƒ‰í•˜ëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤. ì—¬ê¸°ì„œ ìƒíƒœ ê³µê°„(state space)ë¼ëŠ” ìš©ì–´ëŠ” ê²½ë¡œ ê³„íšì—ì„œ ë³´í†µ ê³ ë ¤ë˜ëŠ” ê²ƒë³´ë‹¤ ë” ì¼ë°˜ì ì¸ ê°œë…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ê³ ì •ëœ ì¥ì• ë¬¼ ì˜ì—­ $X_{obs} \subset X$ì´ ì¡´ì¬í•œë‹¤ê³  ê°€ì •í•˜ë©°, ì´ ì˜ì—­ì€ í”¼í•´ì•¼í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ $X_{obs}$ì˜ ëª…ì‹œì ì¸ í‘œí˜„ì€ ì œê³µë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì£¼ì–´ì§„ ìƒíƒœê°€ ì´ ì˜ì—­ì— í¬í•¨ë˜ëŠ”ì§€ ì—¬ë¶€ë§Œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. $X_{obs}$ì— ìˆëŠ” ìƒíƒœëŠ” ì†ë„ ì œí•œ, ì¶©ëŒ ìœ„ì¹˜, í˜¹ì€ ë‹¤ì–‘í•œ í•´ì„ì„ í¬í•¨í•  ìˆ˜ ìˆìœ¼ë©° ì´ëŠ” ì‘ìš©ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. RRT(Rapidly-exploring Random Tree)ëŠ” ëª¨ë“  ê¼­ì§“ì ì´ ììœ  ìƒíƒœ ê³µê°„ $X_{free} \subset X$ (ì¦‰, $X_{obs}$ì˜ ì—¬ì§‘í•©)ì— ì†í•˜ë„ë¡ êµ¬ì„±ëœë‹¤. ë˜í•œ RRTì˜ ê° ê°„ì„ ì€ ì „ì ìœ¼ë¡œ $X_{free}$ ë‚´ì— ìœ„ì¹˜í•œ ê²½ë¡œì— í•´ë‹¹í•œë‹¤. ìƒíƒœ ì „ì´ ë°©ì •ì‹ì€ ë¹„í™€ë¡œë…¸ë¯¹ ì œì•½ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ $\dot{x} = f(x, u)$ í˜•íƒœë¡œ ì •ì˜ë©ë‹ˆë‹¤. ë²¡í„° $u$ëŠ” ì…ë ¥ì˜ ì§‘í•© $U$ì—ì„œ ì„ íƒë˜ë©°, $\dot{x}$ëŠ” ì‹œê°„ì— ë”°ë¥¸ ìƒíƒœì˜ ë¯¸ë¶„ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ê³ ì •ëœ ì‹œê°„ ê°„ê²© $\Delta t$ ë™ì•ˆ í•¨ìˆ˜ $f$ë¥¼ ì ë¶„í•¨ìœ¼ë¡œì¨, ì´ˆê¸° ìƒíƒœ $x$ì™€ ì…ë ¥ $u$ì— ëŒ€í•´ ë‹¤ìŒ ìƒíƒœ $x_{new}$ë¥¼ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í™€ë¡œë…¸ë¯¹ì˜ ê²½ìš°, $f(x, u) = u$ë¡œ ì •ì˜í•  ìˆ˜ ìˆìœ¼ë©°, $|u| \leq 1$ë¡œ ì œí•œë©ë‹ˆë‹¤. ì´ëŠ” ëª¨ë“  ë°©í–¥ìœ¼ë¡œ ì‹œìŠ¤í…œì„ ì´ë™ì‹œí‚¬ ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ë°˜ë©´, ë¹„í™€ë¡œë…¸ë¯¹ ë¬¸ì œì—ì„œëŠ” ì„ íƒëœ $f$ë¡œ ì¸í•´ ë‹¤ìŒ ìƒíƒœê°€ ì œì•½ì„ ë°›ìŠµë‹ˆë‹¤:</p> <p>ì£¼ì–´ì§„ ì´ˆê¸° ìƒíƒœ ìƒíƒœ $x_{init}$ì— ëŒ€í•´, ê¼­ì§“ì  ìˆ˜ê°€ $K$ì¸ RRT $\mathcal{T}$ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
<span class="nc">GENERATE_RRT</span><span class="p">(</span><span class="n">x_init</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">ğ’¯</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">x_init</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">K</span> <span class="n">do</span>
        <span class="n">x_rand</span> <span class="o">=</span> <span class="nc">RANDOM_STATE</span><span class="p">()</span>
        <span class="n">x_near</span> <span class="o">=</span> <span class="nc">NEAREST_NEIGHBOR</span><span class="p">(</span><span class="n">x_rand</span><span class="p">,</span> <span class="n">ğ’¯</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="nc">SELECT_INPUT</span><span class="p">(</span><span class="n">x_rand</span><span class="p">,</span> <span class="n">x_near</span><span class="p">)</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="nc">NEW_STATE</span><span class="p">(</span><span class="n">x_near</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">ğ’¯</span><span class="p">.</span><span class="nf">add_vertex</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">ğ’¯</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">x_near</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ğ’¯</span>

</code></pre></div></div> <p>ÏëŠ” ì‚¬íƒœ ê³µê°„ ìƒì˜ ê±°ë¦¬ ì¸¡ì • ê¸°ì¤€ì„ ë‚˜íƒ€ë‚´ë©°, íŠ¸ë¦¬ $\mathcal{T}$ì˜ ì²« ë²ˆì§¸ ê¼­ì§“ì ì€ $x_{init} \in X_{free}$ì…ë‹ˆë‹¤. ê° ë°˜ì¡±ì—ì„œ ë¬´ì‘ìœ„ ìƒíƒœ $x_{rand}$ëŠ” ìœ í•œí•œ ê³µê°„ì´ë¼ ê°€ì •ëœ $X$ì—ì„œ ì„ íƒë˜ë©°, Ïë¥¼ ê¸°ì¤€ìœ¼ë¡œ $x_{rand}$ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ê¼­ì§“ì  $x_{near}$ë¥¼ ì°¾ìŠµë‹ˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ, $x_{near}$ì—ì„œ $x_{rand}$ê¹Œì§€ ê±°ë¦¬ë¥¼ ìµœì†Œí™”í•˜ëŠ” ì…ë ¥ $u$ë¥¼ ì„ íƒí•˜ì—¬ $x_{new}$ê°€ $x_{free}$ ë‚´ì— ìˆë„ë¡ í•©ë‹ˆë‹¤.</p> <p>ì¶©ëŒ ê²€ì¶œì€ V-Clipê°™ì€ ì ì§„ì  ë°©ë²•ìœ¼ë¡œ ìˆ˜í–‰ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. NEW STATEëŠ” ê°€ëŠ¥í•œ ìƒˆ ìƒíƒœë¥¼ í‰ê°€í•˜ê¸° ìœ„í•´ ê° ì…ë ¥ $u$ì— ëŒ€í•´ í˜¸ì¶œë˜ë©° $U$ê°€ ìœ í•œí•˜ì§€ ì•Šì€ ê²½ìš° ì´ì‚°í™”í•˜ê±°ë‚˜ ìµœì í™” ê¸°ë²•ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì…ë ¥ $u$ë¥¼ ì ìš©í•˜ì—¬ ì–»ì€ ìƒˆ ìƒíƒœ $x_{new}$ëŠ” íŠ¸ë¦¬ì— ê¼­ì§“ì ìœ¼ë¡œ ì¶”ê°€ë˜ê³  ê°„ì„  $(x_{near}, x_{new})$ëŠ” $u$ì™€ í•¨ê»˜ ê¸°ë¡ë©ë‹ˆë‹¤.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotpib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">random</span>

<span class="c1"># initial setting
</span><span class="n">X_LIMITS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">Y_LIMITS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">STEP_SIZE</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">NUM_VERTICES</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">GOAL_RADIUS</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">random_state</span><span class="p">():</span>
    <span class="nf">return</span><span class="p">(</span>
        <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">X_LIMITS</span><span class="p">),</span>
        <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">Y_LIMITS</span><span class="p">)</span>
        <span class="p">)</span>

<span class="c1">#find nearest node
</span><span class="k">def</span> <span class="nf">nearest_vertex</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x_rand</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">min</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span><span class="nf">distance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x_rand</span><span class="p">))</span>

<span class="c1">#calc new state (simple euler integration)
</span><span class="k">def</span> <span class="nf">new_state</span><span class="p">(</span><span class="n">x_near</span><span class="p">,</span> <span class="n">x_rand</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">STEP_SIZE</span><span class="p">):</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x_rand</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x_near</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_near</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">/</span> <span class="n">norm</span>
    <span class="n">x_new</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x_near</span><span class="p">)</span> <span class="o">+</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">step_size</span>
    <span class="k">return</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>

<span class="c1">#RRT
</span><span class="k">def</span> <span class="nf">generate_rrt</span><span class="p">(</span><span class="n">x_init</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">NUM_VERTICES</span><span class="p">):</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_init</span><span class="p">]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range </span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">x_rand</span> <span class="o">=</span> <span class="nf">random_state</span><span class="p">()</span>
        <span class="n">x_near</span> <span class="o">=</span> <span class="nf">nearest_vertex</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="n">x_rand</span><span class="p">)</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="nf">new_state</span><span class="p">(</span><span class="n">x_near</span><span class="p">,</span> <span class="n">x_rand</span><span class="p">)</span>
        <span class="n">tree</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">edges</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">x_near</span><span class="p">,</span> <span class="n">x_new</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">tree</span><span class="p">,</span> <span class="n">edges</span>
    
<span class="k">def</span> <span class="nf">plot_rrt</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">x_init</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="nf">for </span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="sh">'</span><span class="s">b-</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x_init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="sh">'</span><span class="s">ro</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Start</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">RRT in 2D Space</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="n">X_LIMITS</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">ylim</span><span class="p">(</span><span class="n">Y_LIMITS</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">gca</span><span class="p">().</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
        
<span class="k">if</span> <span class="n">__name__</span> <span class="o">=</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">x_init</span> <span class="o">=</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">tree</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="nf">generate_rrt</span><span class="p">(</span><span class="n">x_init</span><span class="p">)</span>
    <span class="nf">plot_rrt</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">x_init</span><span class="p">)</span>

</code></pre></div></div> <p>ì‰½ê²Œ ë‹¤ì‹œ í•œ ë²ˆ ì •ë¦¬í•˜ìë©´ RRTëŠ” ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì•ˆ ìƒíƒœì—ì„œ, ë¬´ì‘ìœ„ì˜ ì ë“¤ì„ ë°œìƒì‹œí‚¤ê³  ê·¸ ì ë“¤ ì¤‘ í•˜ë‚˜ë¡œ ì´ë™í•©ë‹ˆë‹¤. ë§Œì•½ ì¥ì• ë¬¼ì´ ìˆë‹¤ë©´ ë‹¤ì‹œ í•œ ë²ˆ ë¬´ì‘ìœ„ ì ë“¤ ì¤‘ í•˜ë‚˜ë¡œ ëŒì•„ì˜¤ê³ , ì´ë¥¼ ë°˜ë³µí•˜ì—¬ ëª©ì  ì§€ì ê¹Œì§€ ë„ì°©í•˜ê²Œí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.</p> <p>Reference: @article{LaValle1998RapidlyexploringRT, title={Rapidly-exploring random trees : a new tool for path planning}, author={Steven M. LaValle}, journal={The annual research report}, year={1998}, url={https://api.semanticscholar.org/CorpusID:14744621} }</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="path_planning"/><summary type="html"><![CDATA[reviews the basic of RRT]]></summary></entry><entry><title type="html">Rapidly-Exploring Random Tree Star (RRT*)</title><link href="https://daheesong.github.io/blog/2025/OptimizedRRT/" rel="alternate" type="text/html" title="Rapidly-Exploring Random Tree Star (RRT*)"/><published>2025-07-22T14:20:34+00:00</published><updated>2025-07-22T14:20:34+00:00</updated><id>https://daheesong.github.io/blog/2025/OptimizedRRT</id><content type="html" xml:base="https://daheesong.github.io/blog/2025/OptimizedRRT/"><![CDATA[<p>RRT<em>ëŠ” RRTì˜ ìµœì í™”ëœ ë²„ì „ì…ë‹ˆë‹¤. ë…¸ë“œì˜ ìˆ˜ê°€ ë¬´í•œì— ê°€ê¹Œì›Œì§ˆìˆ˜ë¡, RRT</em> ì•Œê³ ë¦¬ì¦˜ì€ ëª©í‘œ ì§€ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì œê³µí•˜ê²Œ ë©ë‹ˆë‹¤. í˜„ì‹¤ì ìœ¼ë¡œëŠ” ì‹¤í˜„ ë¶ˆê°€ëŠ¥í•˜ë”ë¼ë„, ì´ ë¬¸ì¥ì€ ì•Œê³ ë¦¬ì¦˜ì´ ìµœë‹¨ ê²½ë¡œë¥¼ ìƒì„±í•˜ëŠ” ë°©í–¥ìœ¼ë¡œ ì‘ë™í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. RRT*ì˜ ê¸°ë³¸ ì›ë¦¬ëŠ” RRTì™€ ë™ì¼í•˜ì§€ë§Œ, ë‘ ê°€ì§€ ê¸°ëŠ¥ì´ ì¶”ê°€ë˜ì–´ ê²°ê³¼ëŠ” í¬ê²Œ ë°œì „í•©ë‹ˆë‹¤.</p> <p>ì²« ë²ˆì§¸, RRT*ëŠ” ê° ì •ì ì´ ë¶€ëª¨ ì •ì ìœ¼ë¡œë¶€í„° ì´ë™í•œ ê±°ë¦¬ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤. ì´ë¥¼ cost()ë¼ê³  í•˜ë©°, ê·¸ë˜í”„ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œê°€ ì°¾ì•„ì§„ í›„, ìƒˆë¡œìš´ ë…¸ë“œë¡œë¶€í„° ì¼ì • ë°˜ê²½ ë‚´ì— ìˆëŠ” ì´ì›ƒ ë…¸ë“œë“¤ì´ ê²€ì‚¬ë©ë‹ˆë‹¤. ì´ ë•Œ, ê·¼ì ‘ ë…¸ë“œë³´ë‹¤ ë” ì ì€ cost()ë¥¼ ì§€ë‹Œ ë…¸ë“œê°€ ë°œê²¬ë˜ë©´, ê·¸ ê·¼ì ‘ ë…¸ë“œë¥¼ ë” ì €ë ´í•œ ìƒˆë¡œìš´ ë…¸ë“œë¡œ ëŒ€ì²´í•˜ê²Œ ë©ë‹ˆë‹¤. ì´ ê¸°ëŠ¥ì˜ íš¨ê³¼ëŠ” RRTì˜ ì •ìœ¡ë©´ì²´ êµ¬ì¡°ê°€ ì•„ë‹Œ íŠ¸ë¦¬ êµ¬ì¡°ì˜ ë¶€ì±„ê¼´ë¡œ ë»—ì–´ ë‚˜ê°€ëŠ” ê°€ì§€ë“¤ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/RRTs1-480.webp 480w,/assets/img/RRTs1-800.webp 800w,/assets/img/RRTs1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/RRTs1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> source from https://www.linkedin.com/pulse/rrt-rapidly-exploring-random-tree-python-based-animesh-sarkar-xrqrc </div> <p>ë‘ ë²ˆì§¸ ì°¨ì´ì ì€ íŠ¸ë¦¬ì˜ ì¬ë°°ì„ (rewiring)ì…ë‹ˆë‹¤. ì •ì ì´ ê°€ì¥ ì €ë ´í•œ ì´ì›ƒ ë…¸ë“œì— ì—°ê²°ëœ í›„, ì´ì›ƒ ë…¸ë“œë“¤ì´ ë‹¤ì‹œ í•œ ë²ˆ ê²€ì‚¬ë©ë‹ˆë‹¤. ì´ì›ƒ ë…¸ë“œê°€ ìƒˆë¡œ ì¶”ê°€ëœ ì •ì ì— ì—°ê²°ë˜ì—ˆì„ ë•Œ, cost()ê°€ ì¤„ì–´ë“ ë‹¤ë©´, í•´ë‹¹ ì´ì›ƒ ë…¸ë“œëŠ” ìƒˆ ì •ì ìœ¼ë¡œ ë‹¤ì‹œ ì—°ê²°ë©ë‹ˆë‹¤. ì´ ë°©ë²• ë•ë¶„ì— ê²½ë¡œëŠ” ë¶€ë“œëŸ½ê²Œ ì—°ê²°ë©ë‹ˆë‹¤.</p> <p>RRTëŠ” ë§¤ìš° ì§ì„ ì ì¸ ê²½ë¡œë¥¼ ë§Œë“¤ì–¸ì• ë©°, ìƒì„±ëœ ê·¸ë˜í”„ëŠ” RRTì˜ ê·¸ë˜í”„ì™€ ë‹¤ë¦…ë‹ˆë‹¤. ì¥ì• ë¬¼ì´ ë§ì€ ë³µì¡í•œ í™˜ê²½ì—ì„œ ìµœì ì˜ ê²½ë¡œë¥¼ ì°¾ì„ ë•Œ, RRT<em>ì˜ êµ¬ì¡°ëŠ” ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤. ëª©ì ì§€ê°€ ë³€ê²½ë˜ë”ë¼ë„, ì›ë˜ ìƒì„±ëœ ê·¸ë˜í”„ëŠ” ì—¬ì „íˆ í•´ë‹¹ ì˜ì—­ ë‚´ ëŒ€ë¶€ë¶„ì˜ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ë¹ ë¥¸ ê²½ë¡œë¥¼ ë‚˜íƒ€ë‚´ë¯€ë¡œ í™œìš©ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³  RRT</em>ëŠ” ì„±ëŠ¥ ì €í•˜ë¼ëŠ” ë‹¨ì ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì´ì›ƒ ë…¸ë“œë¥¼ ê²€ì‚¬í•˜ê³  ê·¸ë˜í”„ë¥¼ ì¬ë°°ì„ í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì¥ì• ë¬¼ íšŒí”¼ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ëŠ” ë°ì— ë“œëŠ” ë§ì€ ì†Œìš” ì‹œê°„ì´ ë“¤ì§€ë§Œ, ìƒì„±ëœ ê²½ë¡œì˜ ìš°ìˆ˜ì„±ì„ ë¶€ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p> <p>ë‹¤ìŒì€ RRT*ì˜ pseudo ì½”ë“œì…ë‹ˆë‹¤:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
<span class="n">Rad</span> <span class="o">=</span> <span class="n">r</span>
<span class="nc">G</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">)</span>
<span class="n">For</span> <span class="n">itr</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">Xnew</span> <span class="o">=</span> <span class="nc">RandomPosition</span><span class="p">()</span>
    <span class="n">If</span> <span class="nc">Obstacle</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span> <span class="o">==</span> <span class="bp">True</span><span class="p">,</span> <span class="k">try</span> <span class="n">again</span>
    <span class="n">Xnearest</span> <span class="o">=</span> <span class="nc">Nearest</span><span class="p">(</span><span class="nc">G</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">),</span> <span class="n">Xnew</span><span class="p">)</span>
    <span class="nc">Cost</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span> <span class="o">=</span> <span class="nc">Distance</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">Xnearest</span><span class="p">)</span>
    <span class="n">Xbest</span><span class="p">,</span> <span class="n">Xneighbors</span> <span class="o">=</span> <span class="nf">findNeighbors</span><span class="p">(</span><span class="nc">G</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">),</span> <span class="n">Xnew</span><span class="p">,</span> <span class="n">Rad</span><span class="p">)</span>
    <span class="n">Link</span> <span class="o">=</span> <span class="nc">Chain</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">Xbest</span><span class="p">)</span>
    <span class="n">For</span> <span class="n">x</span><span class="err">`</span> <span class="ow">in</span> <span class="n">Xneighbors</span>
        <span class="n">If</span> <span class="nc">Cost</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span> <span class="o">+</span> <span class="nc">Distance</span><span class="p">(</span><span class="n">Xnew</span><span class="p">,</span><span class="n">x</span><span class="sb">`) &lt; Cost(x`</span><span class="p">)</span>
            <span class="nc">Cost</span><span class="p">(</span><span class="n">x</span><span class="sb">`) = Cost(Xnew) + Distance(Xnew, x`</span><span class="p">)</span>
            <span class="nc">Parent</span><span class="p">(</span><span class="n">x</span><span class="err">`</span><span class="p">)</span> <span class="o">=</span> <span class="n">Xnew</span>
            <span class="n">G</span> <span class="o">+=</span> <span class="p">{</span><span class="n">Xnew</span><span class="p">,</span> <span class="n">x</span><span class="err">`</span><span class="p">}</span>
    <span class="n">G</span> <span class="o">+=</span> <span class="n">Link</span>
<span class="k">return</span> <span class="n">G</span>

</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="mf">0.0</span>
        
<span class="k">class</span> <span class="nc">RRTStar</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">map_area</span><span class="p">,</span> <span class="n">obstacle_lst</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">goal_sample_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">goal</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="o">*</span><span class="n">goal</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">map_area</span> <span class="o">=</span> <span class="n">map_area</span>
        <span class="n">self</span><span class="p">.</span><span class="n">obstacle_lst</span> <span class="o">=</span> <span class="n">obstacle_lst</span>
        <span class="n">self</span><span class="p">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">goal_sample_rate</span> <span class="o">=</span> <span class="n">goal_sample_rate</span>
        <span class="n">slef</span><span class="p">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">start</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">search_radius</span> <span class="o">=</span> <span class="mf">5.0</span>
        
    <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">max_iter</span><span class="p">):</span>
                <span class="n">rnd</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">sample</span><span class="p">()</span>
                <span class="n">nearest_node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_nearest_node</span><span class="p">(</span><span class="n">rnd</span><span class="p">)</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">steer</span><span class="p">(</span><span class="n">nearest_node</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_collision</span><span class="p">(</span><span class="n">new_node</span><span class="p">):</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find_neighbors</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                    <span class="n">min_cost_node</span> <span class="o">=</span> <span class="n">nearest_node</span>
                    <span class="n">min_cost</span> <span class="o">=</span> <span class="n">nearest_node</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">nearest_node</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                        <span class="n">cost</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_cllision_edge</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">:</span>
                            <span class="n">min_cost</span> <span class="o">=</span> <span class="n">cost</span>
                            <span class="n">min_cost_node</span> <span class="o">=</span> <span class="n">neighbor</span>
                            
                    <span class="n">new_node</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">min_cost</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">min_cost_node</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">node_lst</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                            
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span> <span class="c1">#Rewire
</span>                        <span class="n">cost_through_new</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">cost_through_new</span> <span class="o">&lt;</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">cost</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_collision_edge</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">):</span>
                                <span class="n">neighbor</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">new_node</span>
                                <span class="n">neighbor</span><span class="p">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">cost_through_new</span>
                    
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">extract_path</span><span class="p">()</span>
                                
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">goal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">return</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                    
    <span class="k">def</span> <span class="nf">get_nearest_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                                    
    <span class="k">def</span> <span class="nf">steer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">atan2</span><span class="p">(</span><span class="n">to_node</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">from_node</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">to_node</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">from_node</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">step_size</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">from_node</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
                        <span class="n">from_node</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_node</span>
                                    
    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="nf">for </span><span class="p">(</span><span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">obstacle_list</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">ox</span> <span class="o">-</span> <span class="n">node</span><span class="p">.</span><span class="n">x</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">oy</span> <span class="o">-</span> <span class="n">node</span><span class="p">.</span><span class="n">y</span>
            <span class="k">if</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

     <span class="k">def</span> <span class="nf">is_collision_edge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">n1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="n">steps</span> <span class="o">*</span> <span class="p">(</span><span class="n">n2</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">n1</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">n1</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="n">steps</span> <span class="o">*</span> <span class="p">(</span><span class="n">n2</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">n1</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">is_collision</span><span class="p">(</span><span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="nf">hypot</span><span class="p">(</span><span class="n">n1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">n2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">n1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">n2</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_neighbors</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">search_radius</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">node_list</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">extract_path</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">last_node</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">goal</span><span class="p">))</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[(</span><span class="n">last_node</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">last_node</span><span class="p">.</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">last_node</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="n">last_node</span> <span class="o">=</span> <span class="n">last_node</span><span class="p">.</span><span class="n">parent</span>
            <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">last_node</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">last_node</span><span class="p">.</span><span class="n">y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                                
   <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">node_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">node</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">y</span><span class="p">],</span> <span class="sh">"</span><span class="s">-g</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">for </span><span class="p">(</span><span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">obstacle_list</span><span class="p">:</span>
            <span class="n">circle</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nc">Circle</span><span class="p">((</span><span class="n">ox</span><span class="p">,</span> <span class="n">oy</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">.</span><span class="nf">add_patch</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="sh">'</span><span class="s">-r</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="sh">"</span><span class="s">ro</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">goal</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">goal</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="sh">"</span><span class="s">bo</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">map_area</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">ax</span><span class="p">.</span><span class="nf">set_aspect</span><span class="p">(</span><span class="sh">'</span><span class="s">equal</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">RRT* Path Planning</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>                                             
                  

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
    <span class="nf">map_area</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="n">obstacle</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#predefined
</span>    
    <span class="n">rrt_star</span> <span class="o">=</span> <span class="nc">RRTStar</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">map_area</span><span class="p">,</span> <span class="n">obstacles</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">rrt_star</span><span class="p">.</span><span class="nf">plan</span><span class="p">()</span>
    <span class="n">rrt_star</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                                                
</code></pre></div></div> <p>Reference: @misc{karaman2011samplingbasedalgorithmsoptimalmotion, title={Sampling-based Algorithms for Optimal Motion Planning}, author={Sertac Karaman and Emilio Frazzoli}, year={2011}, eprint={1105.1186}, archivePrefix={arXiv}, primaryClass={cs.RO}, url={https://arxiv.org/abs/1105.1186}, }</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="path_planning"/><summary type="html"><![CDATA[reviews the basic of RRT*]]></summary></entry><entry><title type="html">An Overview of Path Planning</title><link href="https://daheesong.github.io/blog/2025/an-overview-of-path-planning/" rel="alternate" type="text/html" title="An Overview of Path Planning"/><published>2025-07-20T09:40:30+00:00</published><updated>2025-07-20T09:40:30+00:00</updated><id>https://daheesong.github.io/blog/2025/an-overview-of-path-planning</id><content type="html" xml:base="https://daheesong.github.io/blog/2025/an-overview-of-path-planning/"><![CDATA[<p>Path planning(ê²½ë¡œ ê³„íš)ì˜ ê°œë…ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤: í™˜ê²½ ì •ë³´ë¥¼ ì–¼ë§ˆë‚˜ ì•Œê³  ìˆëŠ”ê°€ì— ë”°ë¼ í™˜ê²½ ì •ë³´ê°€ ì™„ì „íˆ ì•Œë ¤ì§„ global path planningê³¼ ë¶€ë¶„ì ìœ¼ë¡œ í™˜ê²½ ì •ë³´ê°€ ì•Œë ¤ì§„ local path planningìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë˜í•œ í™˜ê²½ ë‚´ ì¥ì• ë¬¼ì´ ì›€ì§ì´ëŠ”ì§€ì˜ ì—¬ë¶€ì— ë”°ë¼ ì¥ì• ë¬¼ì´ ì •ì ì¸ static planningê³¼ ì¥ì• ë¬¼ì´ ë™ì ì¸ dynamic planningìœ¼ë¡œ ë‚˜ë‰  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³ , ëª¨ë°”ì¼ ë¡œë´‡ ì‹œìŠ¤í…œì—ì„œ ì œì–´ ê°€ëŠ¥í•œ ë³€ìˆ˜ì˜ ìˆ˜ê°€ ë¡œë´‡ì˜ attitude ê³µê°„ ì°¨ì›ë³´ë‹¤ ì‘ì€ì§€ì˜ ì—¬ë¶€ì— ë”°ë¼, ì œì–´ ê°€ëŠ¥í•œ ììœ ë„ê°€ ì „ì²´ ìì„¸ ê³µê°„ë³´ë‹¤ ê°™ê±°ë‚˜ ë§ì€ (ex, ë“œë¡ , x-yí‰ë©´ì—ì„œ ì›€ì§ì´ëŠ” ë¡œë´‡ íŒ”) holonomic systemì˜ ìš´ë™ ê³„íš, ê·¸ì™€ ë°˜ëŒ€ ë˜ëŠ” non-holonomic systemì˜ ìš´ë™ ê³„íšìœ¼ë¡œ ë‚˜ë‰  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p> <p>Global path planningì€ ì‹œì‘ì ì—ì„œ ëª©í‘œì§€ì ê¹Œì§€ì˜ ìˆœìˆ˜í•œ ê¸°í•˜í•™ì  ê²½ë¡œë¥¼ ë‹¤ë£¹ë‹ˆë‹¤. Local path planningì€ obstacle avoidance planning, dynamic path planning, real-time navigation planningì´ë¼ê³ ë„ ë¶ˆë¦½ë‹ˆë‹¤. ì¥ì• ë¬¼ì„ íƒì§€í•˜ê³  ì›€ì§ì´ëŠ” ì¥ì• ë¬¼ì˜ ê´˜ì ì„ ì¶”ì í•˜ë©° ë‹¤ìŒ ìœ„ì¹˜ë¥¼ ì˜ˆì¸¡í•˜ëŠ”ë° ì´ˆì ì„ ë§ì¶¥ë‹ˆë‹¤. ê²°ê³¼, í˜„ì¬ ì¡´ì¬í•˜ëŠ” ì¶©ëŒ ìœ„í—˜ê³¼ ì ì¬ì ì¸ ì¶©ëŒ ìœ„í—˜ì´ í¬í•¨ëœ ì§€ë„ë¥¼ ìƒì„±í•˜ê²Œ ë©ë‹ˆë‹¤.</p> <p>Path planningì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ì„œëŠ”, ìš°ì„  ëª¨ë°”ì¼ ë¡œë´‡ì˜ ì´ë™ í™˜ê²½ ëª¨ë¸ì„ êµ¬ì¶•í•´ì•¼ í•©ë‹ˆë‹¤. í™˜ê²½ì€ ë³´í†µ ì •ì (static)ê³¼ ë™ì (dynamic) í™˜ê²½ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì •ì  í™˜ê²½ì€ ìƒëŒ€ì ìœ¼ë¡œ ë‹¨ìˆœí•˜ì§€ë§Œ, ëŒ€ë¶€ë¶„ì˜ í™˜ê²½ì€ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³€í™”í•˜ëŠ” ë™ì  í™˜ê²½ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ íŠ¹ì„±ì€ ê²½ë¡œ ê³„íš ì•Œê³ ë¦¬ì¦˜ì— ë†’ì€ ì‹¤ì‹œê°„ì„±ê³¼ robustnessë¥¼ ìš”êµ¬í•©ë‹ˆë‹¤. í˜„ì¬ ì‚¬ìš©ë˜ëŠ” í™˜ê²½ ëª¨ë¸ë§ ë°©ë²•ì€ ì£¼ë¡œ ëª¨ë°”ì¼ ë¡œë´‡ì˜ ì£¼ë³€ í™˜ê²½ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ì—¬, map subsystemì„ í†µí•´ ê¸°í•˜í•™ì /ìœ„ìƒí•™ì  íŠ¹ì„±ì„ ê°–ì¶˜ ì§€ë„ìƒì— í‘œí˜„í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ ì§€ë„ì—ëŠ” ë„ë¡œ í˜¹ì€ ì‚¬ë¬¼ê°„ì˜ ì—°ê²° ê´€ê³„ê°€ í¬í•¨ë©ë‹ˆë‹¤. ê°€ì¥ ë‹¨ìˆœí•œ ì§€ë„ ìƒì„± ë°©ë²•ì€ í•­ê³µ ì‚¬ì§„ì—ì„œ ì´ë¥¼ ì¶”ì¶œí•˜ì—¬ ë¼ë²¨ë§í•˜ëŠ” ê²ƒ ì…ë‹ˆë‹¤. ë™ì  í™˜ê²½ì—ëŠ” MOT(Multi-object tracking) ë˜ëŠ” DATMO (Detection and tracking moving object) ì„œë¸Œì‹œìŠ¤í…œì´ ì‚¬ìš©ë˜ì–´, ë¡œë´‡ ì£¼ë³€ì˜ ì¥ì• ë¬¼ì˜ ìœ„ì¹˜ë‚˜ ë°©í–¥ì„ íƒì§€ ë° ì¶”ì í•©ë‹ˆë‹¤.</p> <p>ì „í†µì ì¸ í™˜ê²½ ëª¨ë¸ë§ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:</p> <ul> <li>Multi-object tracking: ì„¼ì„œ ë°ì´í„°ë¥¼ ë¶„í• í•˜ê³  ë¶„í• ëœ ë°ì´í„°ë¥¼ ì¥ì• ë¬¼ì— ì—°ê²°í•˜ì—¬, ëŒ€ìƒë³„ ìœ„ì¹˜ ì¶”ì •ì„ ìœ„í•´ í• ë‹¹ëœ ë°ì´í„°ë¥¼ í‰ê·  ì²˜ë¦¬í•˜ê³  í•„í„°(ex, Kalman Filter or Particle Filter)ë¡œ ìœ„ì¹˜ë¥¼ ê°±ì‹ í•œë‹¤.</li> <li>Model based Approach: ì„¼ì„œì˜ ë¬¼ë¦¬ ëª¨ë¸ê³¼ ê°ì²´ì˜ ê¸°í•˜í•™ ëª¨ë¸ì„ í™œìš©í•˜ì—¬ í•„í„°(ex, Particle filter)ë¡œ ì§ì ‘ ë°ì´í„°ë¥¼ í•´ì„í•œë‹¤.</li> <li>Stereo Vision based method: ìŠ¤í…Œë ˆì˜¤ ì´ë¯¸ì§€ì—ì„œ ì œê³µë˜ëŠ” ìƒ‰ìƒ ë° ê¹Šì´ ì •ë³´ë¥¼ ì´ìš©í•´ ì›€ì§ì´ëŠ” ì¥ì• ë¬¼ì„ íƒì§€ ë° ì¶”ì í•œë‹¤. ESSëŠ” ì „ë°© ì¹´ë©”ë¼ì˜ ë™ê¸°í™”ëœ ì˜ìƒ ë§Œìœ¼ë¡œ ì¥ì• ë¬¼ì„ íƒì§€í•˜ëŠ” ê¸°ë²•ì„ ì œì•ˆí•œë‹¤.</li> <li>Raster Map based method: occupancy grid mapì„ ë¨¼ì € êµ¬ì¶•í•˜ê³ , ë¶„í• , ì—°ê´€, í•„í„°ë§ ë‹¨ê³„ë¥¼ í†µí•´ ê°ì²´ ìˆ˜ì¤€ì˜ ì¥ë©´ í‘œí˜„ì„ ì œê³µí•œë‹¤.</li> <li>Sensor fusion: ë‹¤ì–‘í•œ ì„¼ì„œë¥¼ ìœµí•©í•˜ì—¬ í™˜ê²½ ì¸ì‹ì„ í–¥ìƒí•œë‹¤.</li> <li>Deep Laerning: DNNì„ í†µí•´ ì´ë™ ì¥ì• ë¬¼ì˜ ìœ„ì¹˜ ë° ê¸°í•˜í•™ì  íŠ¹ì§•ì„ ì¶”ì¶œí•˜ê³ , í˜„ì¬ ì¹´ë©”ë¼ ë°ì´í„°ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë¯¸ë˜ ìƒíƒœë¥¼ ì¶”ì í•œë‹¤.</li> <li>V2X: Vehicle to Everythingì€ ì°¨ëŸ‰ ê°„, ì°¨ëŸ‰ê³¼ ì¸í”„ë¼ ê°„, ì°¨ëŸ‰ê³¼ ë³´í–‰ì ê°„, ì°¨ëŸ‰ê³¼ ë„¤íŠ¸ì›Œí¬ ê°„ í†µì‹ ì„ ê°€ëŠ¥ì¼€ í•¨ìœ¼ë¡œì„œ ì‹¤ì‹œê°„ ë„ë¡œ ìƒí™©, ì •ë³´, ë³´í–‰ì ì •ë³´ ë“±ì„ ì•Œ ìˆ˜ ìˆìœ¼ë©°, V2V(ehicle), V2I(nfra), V2P(erson), V2N(etwork)ì„ í¬í•¨í•œë‹¤.</li> </ul> <p>Path planning ì•Œê³ ë¦¬ì¦˜ì€ í¬ê²Œ ì„¸ ê°€ì§€ë¡œ ë‚˜ë‰©ë‹ˆë‹¤. 1) ì§€ë„ ê¸°ë°˜ì˜ ì „í†µì ì¸ ê²½ë¡œ ê³„íš ì•Œê³ ë¦¬ì¦˜ (Dijkstra, A*), 2) ìƒë¬¼ ëª¨ë°© ê¸°ë°˜ì˜ ì§€ëŠ¥í˜• ê²½ë¡œ ê³„íš ì•Œê³ ë¦¬ì¦˜ (PSO, ìœ ì „ì ì•Œê³ ë¦¬ì¦˜, ê°•í™” í•™ìŠµ), 3) ìƒ˜í”Œë§ ê¸°ë°˜ì˜ ê²½ë¡œ ê³„íš ì•Œê³ ë¦¬ì¦˜ (RRT).</p> <p>ì§€ë„ ê¸°ë°˜ ì „í†µ ê²½ë¡œ ê³„íš ì•Œê³ ë¦¬ì¦˜ì€ ëŒ€í‘œì ìœ¼ë¡œ 5ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤: Dijkstra, a<em>, D</em>, LPA<em>, D</em> Lite. ì´ë“¤ì€ A* ê³„ì—´ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰í•˜ê¸° ì „ í™˜ê²½ ëª¨ë¸ì„ ë°˜ë“œì‹œ êµ¬ì¶•í•´ì•¼í•©ë‹ˆë‹¤.</p> <p>Dijkstra ì•Œê³ ë¦¬ì¦˜ì€ íƒìš•ì  ì›ì¹™ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ì—¬ ë…¸ë“œë¥¼ í•˜ë‚˜ì”© ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•˜ê³ , ì™„í™”(relaxation) ë°©ë²•ìœ¼ë¡œ ê²½ë¡œë¥¼ ìµœì í™”í•©ë‹ˆë‹¤. ìµœì¢…ì ìœ¼ë¡œ ìµœì  ê²½ë¡œë¥¼ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•˜ì—¬ ìµœì  ê²½ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ, ì§€ë„ ë°ì´í„°ê°€ ì‘ì„ ë•ŒëŠ” íš¨ê³¼ì ì´ì§€ë§Œ, ë°ì´í„° ì–‘ì´ ë§ì„ ê²½ìš° ì„±ëŠ¥ì´ ê¸‰ê²©íˆ ë–¨ì–´ì§‘ë‹ˆë‹¤. ìš°ì„ ìˆœìœ„ íì™€ ì—­ N-íŠ¸ë¦¬ë¥¼ ê²°í•©í•˜ë©´ ì„±ëŠ¥ì´ í–¥ìƒë  ìˆ˜ ìˆìœ¼ë©°, ì œí•œëœ ë²”ìœ„ ë‚´ì—ì„œì˜ íƒìƒ‰ ë°©ì‹ì„ ë„ì…í•˜ë©´ íƒìƒ‰ ë²”ìœ„ ë° íšŸìˆ˜ë¥¼ ì¤„ì—¬ ê²€ìƒ‰ íš¨ìœ¨ì„ í–¥ìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p> <p>A* ì•Œê³ ë¦¬ì¦˜ì€ Dijkstra ì•Œê³ ë¦¬ì¦˜ì„ ê°œì„ í•œ heuristic íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì¶”ì • í•¨ìˆ˜ë¥¼ ì¶”ê°€í•˜ì—¬, íƒìƒ‰ ìœ„ì¹˜ì™€ ëª©í‘œ ì§€ì  ê°„ì˜ ê±°ë¦¬ë¥¼ ì˜ˆì¸¡í•¨ìœ¼ë¡œì„œ íƒìƒ‰ ë°©í–¥ì„ ëª©í‘œ ì§€ì  ìª½ìœ¼ë¡œ ìš°ì„  ìœ ë„ í•©ë‹ˆë‹¤. ê¸°ë³¸ í•¨ìˆ˜ í˜•íƒœëŠ” f(x) = g(x) + h(x)ì…ë‹ˆë‹¤. g(x)ëŠ” ì‹œì‘ì ì—ì„œ í˜„ì¬ ë…¸ë“œ xê¹Œì§€ì˜ ì‹¤ì œ ê±°ë¦¬ë¥¼ ì˜ë¯¸í•˜ë©°, h(x)ëŠ” í˜„ì¬ ë…¸ë“œ xì—ì„œ ëª©í‘œì ê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬ ì¶”ì •ê°’ì…ë‹ˆë‹¤. Dijkstraì— ë¹„í•´ íƒìƒ‰ íšŸìˆ˜ê°€ ì¤„ê³  ì†ë„ê°€ ë¹¨ë¼ì„œ ë„ë¦¬ ì‚¬ìš©ë©ë‹ˆë‹¤. ë˜í•œ, ëª©í‘œ ì§€ì  ê·¼ì²˜ë¡œ ê°ˆìˆ˜ë¡ íƒìƒ‰ ë²”ìœ„ê°€ ì¢ì•„ì§‘ë‹ˆë‹¤.</p> <p>D* ì•Œê³ ë¦¬ì¦˜ì€ Dynamic A* ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ëª©í‘œì ì—ì„œ ì‹œì‘ì  ë°©í–¥ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” Reverse Incremental Search ë°©ì‹ì„ ì‚¬ìš©í•˜ë©°, ë„ì¤‘ ì¥ì• ë¬¼ì´ ë‚˜íƒ€ë‚˜ë©´, ê¸°ì¡´ ê±°ë¦¬ ì •ë³´ë¥¼ ì¬ì‚¬ìš©í•˜ì—¬ ì „ì²´ ê²½ë¡œë¥¼ ì¬ê³„ì‚°í•˜ì§€ ì•Šê³  ë¶€ë¶„ë§Œ ê°±ì‹ í•©ë‹ˆë‹¤. H(x) = H(y) + C(y,x) ê³µì‹ì„ ì‚¬ìš©í•˜ë©° H(y)ëŠ” yì§€ì ì—ì„œ ëª©í‘œê¹Œì§€ì˜ ê±°ë¦¬ì´ê³ , C(y,x)ëŠ” yì§€ì ì—ì„œ xì§€ì ê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.</p> <p>LPA* ì•Œê³ ë¦¬ì¦˜ì€ Life Planning A*ì˜ ì•½ì–´ë¡œ, Increasement heuristic serarch ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì‹œì‘ì ì—ì„œ íƒìƒ‰ì„ ì‹œì‘í•˜ë©°, keyê°’ì„ ê¸°ì¤€ìœ¼ë¡œ íƒìƒ‰ì„ ì§„í–‰í•©ë‹ˆë‹¤. ëª©í‘œ ì§€ì ì´ ë‹¤ìŒ íƒìƒ‰ ëŒ€ìƒì´ ë˜ë©´ ê³„íšì„ ì™„ë£Œí•˜ê³ , Key ê°’ì€ íœ´ë¦¬ìŠ¤í‹± ìš”ì†Œë¥¼ í¬í•¨í•˜ì—¬ íƒìƒ‰ ë°©í–¥ì— ì˜í–¥ì„ ì¤ë‹ˆë‹¤. ë™ì  í™˜ê²½ì—ì„œë„ ì´ì „ íƒìƒ‰ì—ì„œ ì–»ì€ G ê°’ì„ í™œìš©í•˜ì—¬ ì „ì²´ í™˜ê²½ì„ ì¬ íƒìƒ‰í•˜ì§€ ì•Šê³  ë¹ ë¥´ê²Œ ê²½ë¡œ ì¬ê³„íš ê°€ëŠ¥í•©ë‹ˆë‹¤. G(n)ì€ ì‹œì‘ì ì—ì„œ í˜„ì¬ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ì´ë©°, RHS(n)ì€ min(g(n)+c(n,nâ€™)) (nâ€™ì€ nì˜ ë¶€ëª¨ ë…¸ë“œ), h(n, goal)ì€ ëª©í‘œì— ëŒ€í•œ íœ´ë¦¬ìŠ¤í‹± ê°’ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ë¨¼ì € K1 ê°’ì„ ë¹„êµí•˜ê³ , K1ì´ ì‘ìœ¼ë©´ í•´ë‹¹ ë…¸ë“œë¥¼ ìš°ì„  íƒìƒ‰, K1 = K2ì´ë©´ K2ê°€ ë” ì‘ì€ ë…¸ë“œë¥¼ ìš°ì„ í•˜ë©° íƒìƒ‰í•©ë‹ˆë‹¤.</p> <p>D* Lite ì•Œê³ ë¦¬ì¦˜ì€ LPA*ì„ ê¸°ë°˜ìœ¼ë¡œ ì œì•ˆí•œ ê²½ë¡œ ê³„íš ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. Key ê³„ì‚° ì‹œ ëª©í‘œì (goal) ëŒ€ì‹  ì‹œì‘ì ì„ ê¸°ì¤€ìœ¼ë¡œ í•œ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ë©°, ì•Œê³ ë¦¬ì¦˜ì€ ì—­ë°©í–¥ íƒìƒ‰ìœ¼ë¡œ ì‹œì‘í•˜ì—¬ ìµœì  ê²½ë¡œë¥¼ ì°¾ê³ , ë™ì  ì¥ì• ë¬¼ì´ ë‚˜íƒ€ë‚˜ë©´ êµ­ì§€ì ì¸ ë²”ìœ„ì—ì„œ íƒìƒ‰ì„ ì¬ì‹œì‘í•©ë‹ˆë‹¤. ê²½ë¡œ íƒìƒ‰ ì •ë³´ë¥¼ ì¬í™œìš©í•  ìˆ˜ ìˆê³ , ì¥ì• ë¬¼ë¡œ ì¸í•´ ê¸°ì¤€ ê²½ë¡œì˜ ì‚¬ìš©ì´ ë¶ˆê°€í•  ì‹œ, í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë¹ ë¥´ê²Œ ìµœì  ê²½ë¡œ ì¬ê³„íšì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.</p> <p>ìƒë¬¼ ê¸°ë°˜ì˜ ê²½ë¡œ ê³„íš ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œëŠ” ì‹ ê²½ë§, ê°œë¯¸ êµ°ì§‘ ì•Œê³ ë¦¬ì¦˜, ëŠ‘ëŒ€ êµ°ì§‘ ì•Œê³ ë¦¬ì¦˜, ìœ ì „ ì•Œê³ ë¦¬ì¦˜ ë“±ì´ ìˆìŠµë‹ˆë‹¤. ìœ ì „ ì•Œê³ ë¦¬ì¦˜ì€ ìì—° ì„ íƒê³¼ ë‹¤ìœˆì˜ ì§„í™” ë©”ì»¤ë‹ˆì¦˜ì„ ëª¨ë°©í•˜ì—¬ ìµœì  í•´ë¥¼ íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì£¼ìš” íŠ¹ì§•ì€ í•¨ìˆ˜ì˜ ë„í•¨ìˆ˜ë‚˜ ì—°ì†ì„±ì˜ ì œì•½ ì—†ì´ êµ¬ì¡°ì  ê°œì²´ë¥¼ ì§ì ‘ ë‹¤ë£° ìˆ˜ ìˆìœ¼ë©°, ë‚´ì¬ëœ ë³‘ë ¬ì„±ê³¼ ë›°ì–´ë‚œ ì „ì—­ ìµœì í™” ëŠ¥ë ¥ì„ ê°–ì¶”ê³  ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. í™•ë¥  ê¸°ë°˜ì˜ ë°©ì‹ìœ¼ë¡œ ëª…í™•í•œ ê·œì¹™ ì—†ì´ë„ ìµœì  í•´ íƒìƒ‰ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì‹ ê²½ë§ ì•Œê³ ë¦¬ì¦˜ì€ ë§ì€ ìˆ˜ì˜ ë…¸ë“œ(ë˜ëŠ” ë‰´ëŸ°)ë¡œ êµ¬ì„±ëœ ì—°ì‚° ëª¨ë¸ë¡œ, ê° ë…¸ë“œëŠ” í™œì„±í™” í•¨ìˆ˜ë¼ ë¶ˆë¦¬ëŠ” íŠ¹ì • ì¶œë ¥ í•¨ìˆ˜ë¥¼ ê°€ì§€ë©°, ë…¸ë“œ ê°„ ì—°ê²°ì€ ê°€ì¤‘ì¹˜ë¥¼ í†µí•´ ì‹ í˜¸ ê°•ë„ë¥¼ ì¡°ì ˆí•œë‹¤. ì´ ê°€ì¤‘ì¹˜ëŠ” ì¸ê³µ ì‹ ê²½ë§ì˜ ê¸°ì–µì— í•´ë‹¹í•©ë‹ˆë‹¤. ê°œë¯¸ êµ°ì§‘ ì•Œê³ ë¦¬ì¦˜ì€ í˜„ì¬ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ì§€ëŠ¥í˜• ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ì§€ë§Œ, ë°˜ë³µ íšŸìˆ˜ê°€ ë§ê³  ìˆ˜ë ´ ì†ë„ê°€ ëŠë¦¬ë©° êµ­ì†Œ ìµœì  í•´ì— ë¹ ì§€ê¸° ì‰½ë‹¤ëŠ” ë‹¨ì ì´ ìˆìŠµë‹ˆë‹¤. fuzzy ì•Œê³ ë¦¬ì¦˜ì„ ê²°í•©í•˜ì—¬ ìˆ˜ë ´ ì†ë„ë¥¼ ê°œì„ í•˜ê±°ë‚˜, ìœ ì „ ì•Œê³ ë¦¬ì¦˜ê³¼ì˜ ê²°í•©ì„ í†µí•´ ìµœì  ê²½ë¡œë¥¼ ë„ì¶œí•˜ëŠ” ë°©ì‹ ë“±ì´ ìˆìŠµë‹ˆë‹¤.</p> <p>ìƒ˜í”Œë§ ê¸°ë°˜ ê²½ë¡œ ê³„íš ì•Œê³ ë¦¬ì¦˜ì€ í™•ë¥ ì  ë¡œë“œë§µ(PRM)ê³¼ ë¹ ë¥¸ íƒìƒ‰ ëœë¤ íŠ¸ë¦¬(RRT)ê°€ ëŒ€í‘œì ì…ë‹ˆë‹¤. PRM ì•Œê³ ë¦¬ì¦˜ì€ ê²½ë¡œ ê³µê°„ì—ì„œ ë¬´ì‘ìœ„ë¡œ Nê°œì˜ ë…¸ë“œë¥¼ ì„ íƒí•˜ê³ , ê° ë…¸ë“œë¥¼ ì—°ê²°í•œ ë’¤ ì¥ì• ë¬¼ê³¼ ì¶©ëŒí•˜ëŠ” ì—°ê²°ì„ ì œê±°í•˜ì—¬ ì‹¤í–‰ ê°€ëŠ¥í•œ ê²½ë¡œë¥¼ ìƒì„±í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤. ìƒ˜í”Œë§ í¬ì¸íŠ¸ ìˆ˜ê°€ ì ê±°ë‚˜ ë°°ì¹˜ê°€ ë¹„íš¨ìœ¨ì ì´ë©´ ì•Œê³ ë¦¬ì¦˜ì˜ ì™„ì „ì„±ì´ ë–¨ì–´ì§€ì§€ë§Œ, ìƒ˜í”Œë§ì„ ì¶”ê°€í•˜ë©´ ë³´ì™„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ PRMì€ í™•ë¥ ì  ì™„ì „ì„±ì€ ìˆì§€ë§Œ ìµœì ì„±ì€ ì—†ìŠµë‹ˆë‹¤. RRT (Rapidly exploring random tree)ëŠ” ê²½ë¡œ ê³µê°„ì˜ ëª¨ë¸ë§ì´ í•„ìš” ì—†ê³  íƒìƒ‰ ë²”ìœ„ê°€ ë„“ìœ¼ë©° ë¯¸ì§€ ì˜ì—­ì„ ê´‘ë²”ìœ„í•˜ê²Œ íƒìƒ‰í•  ìˆ˜ ìˆëŠ” ì¥ì ì´ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ê³„ì‚° ë¹„ìš©ì´ í¬ë©°, ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë‹¤ì–‘í•œ ë³€í˜• ì•Œê³ ë¦¬ì¦˜ (Goal-Bias RRT, Bi-RRT, RRT-Connect, Extend RRT, Local-Tree-RRT, Dynamic RRT)ì´ ì¡´ì¬í•©ë‹ˆë‹¤.</p> <p>References: @article{Tang_2021, doi = {10.1088/1755-1315/804/2/022024}, url = {https://dx.doi.org/10.1088/1755-1315/804/2/022024}, year = {2021}, month = {jul}, publisher = {IOP Publishing}, volume = {804}, number = {2}, pages = {022024}, author = {Tang, Zhuozhen and Ma, Hongzhong}, title = {An overview of path planning algorithms}, journal = {IOP Conference Series: Earth and Environmental Science}, abstract = {This paper reviews the basic concepts of path planning, classifies environmental modeling methods, analyzes the significance of V2X environment modeling, and summarizes the existing path planning algorithms. Different algorithm can be adjusted in time according to different environments to improve the efficiency of path planning. In addition, according to the advantages and disadvantages of different algorithms, each algorithm is fused, which can effectively avoid the shortcomings of each algorithm and improve the efficiency of the planning algorithm.} }</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="path_planning"/><summary type="html"><![CDATA[reviews the basic concepts of path planning and summarizes the existing path planning algorithms]]></summary></entry></feed>